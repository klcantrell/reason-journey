// Generated by BUCKLESCRIPT VERSION 5.0.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");

console.log("\nMutation of let bindings");

var myLetBinding = "sup";

var refMyLetBinding = /* record */[/* contents */myLetBinding];

console.log(refMyLetBinding[/* contents */0]);

refMyLetBinding[0] = "yo";

console.log(refMyLetBinding[/* contents */0]);

console.log(myLetBinding);

console.log("\nFunctions");

function add(num1, num2) {
  return num1 + num2 | 0;
}

function add1(param) {
  return 1 + param | 0;
}

var myList = List.map(add1, /* :: */[
      1,
      /* :: */[
        2,
        /* :: */[
          3,
          /* [] */0
        ]
      ]
    ]);

console.log(myList);

function factorial(x) {
  if (x <= 2) {
    return x;
  } else {
    return Caml_int32.imul(x, factorial(x - 1 | 0));
  }
}

console.log(factorial(12));

console.log("recursion");

function fnWithUnit(param) {
  return 2;
}

console.log(2);

console.log("unit type");

function anotherFnWithUnit(x) {
  return /* () */0;
}

console.log(/* () */0);

console.log("named arguments");

function fnWithNamedArgs(name, greeting, timeOfDay) {
  return "" + (String(greeting) + (", " + (String(name) + ("! Good " + (String(timeOfDay) + ".")))));
}

console.log(fnWithNamedArgs("Kal", "Sup", "Morning"));

console.log("destructuring named arguments");

function crossProduct(param, param$1) {
  var b3 = param$1[2];
  var b2 = param$1[1];
  var b1 = param$1[0];
  var a3 = param[2];
  var a2 = param[1];
  var a1 = param[0];
  return /* tuple */[
          Caml_int32.imul(a2, b3) - Caml_int32.imul(a3, b2) | 0,
          Caml_int32.imul(a3, b1) - Caml_int32.imul(a1, b3) | 0,
          Caml_int32.imul(a1, b2) - Caml_int32.imul(a2, b1) | 0
        ];
}

console.log(crossProduct(/* tuple */[
          1,
          2,
          3
        ], /* tuple */[
          2,
          3,
          4
        ]));

console.log("with optional arguments");

function addWithOptional(x, y, param) {
  if (x !== undefined) {
    var x$1 = x;
    if (y !== undefined) {
      return x$1 + y | 0;
    } else {
      return x$1;
    }
  } else if (y !== undefined) {
    return y;
  } else {
    return 0;
  }
}

console.log(addWithOptional(1, undefined, /* () */0));

console.log("how to forward an optional to the function without unwrapping it first");

console.log(addWithOptional(12, 4, /* () */0));

function addWithOptionalWithDefaults($staropt$star, $staropt$star$1, param) {
  var x = $staropt$star !== undefined ? $staropt$star : 0;
  var y = $staropt$star$1 !== undefined ? $staropt$star$1 : 0;
  return x + y | 0;
}

console.log(addWithOptionalWithDefaults(3, 4, /* () */0));

console.log("pipe operators");

console.log(List.sort(Caml_obj.caml_compare, List.filter((function (x) {
                  return x < 5;
                }))(List.map((function (x) {
                    return x + 1 | 0;
                  }), /* :: */[
                  4,
                  /* :: */[
                    2,
                    /* :: */[
                      1,
                      /* :: */[
                        5,
                        /* [] */0
                      ]
                    ]
                  ]
                ]))));

console.log("shorthand for switching on a function argument (works for single arity)");

function someKindOfTupleFn(tuple) {
  var y = tuple[1];
  if (y !== 0) {
    return Caml_int32.div(tuple[0], y);
  } else {
    return -1;
  }
}

exports.myLetBinding = myLetBinding;
exports.refMyLetBinding = refMyLetBinding;
exports.add = add;
exports.add1 = add1;
exports.myList = myList;
exports.factorial = factorial;
exports.fnWithUnit = fnWithUnit;
exports.anotherFnWithUnit = anotherFnWithUnit;
exports.fnWithNamedArgs = fnWithNamedArgs;
exports.crossProduct = crossProduct;
exports.addWithOptional = addWithOptional;
exports.addWithOptionalWithDefaults = addWithOptionalWithDefaults;
exports.someKindOfTupleFn = someKindOfTupleFn;
/*  Not a pure module */
